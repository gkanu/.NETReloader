(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
BeginPackage["DotNETReloader`",{"NETLink`","Global`"}];


(* ::Input::Initialization:: *)
ClearAll[dotNETLoad];


(* ::Input::Initialization:: *)
dotNETLoad::usage="dotNETLoad[code, compiler] takes a C# or F# code in string format and, optionally, a corresponding compiler path, it then attempts to compile the string code into a .NET dll suitable for use with NETLink.
dotNETLoad[{code1, code2, ...}, compiler] takes multiple C# or F# codes in string format, all in the same namespace and, optionally, a corresponding compiler path, it then attempts to compile the string codes into a .NET dll suitable for use with NETLink.";


(* ::Input::Initialization:: *)
dotNETLoad::dirmakeerr="Can not create directory `1`";
dotNETLoad::invst="The loader is not in a valid state. Perhaps some temporary directories do not exist or could not be created";
dotNETLoad::cmperr="The following compilation errors were encountered: \n`1`";
dotNETLoad::langerr="The language `1` is not supported";
dotNETLoad::comperr="The compiler `1` is either not currently supported, or is not a valid compiler name";
dotNETLoad::nameerr="One or more class(es) belongs to a different namespace"


(* ::Input::Initialization:: *)
Options[dotNETLoad]=Options[LoadNETType]/.False->True


(* ::Input::Initialization:: *)
Begin["`Private`"]


(* ::Input::Initialization:: *)
ClearAll[getNamespace,getClass,getErr,getLanguage,getSource,runScript]


(* ::Input::Initialization:: *)
$stateValidQ=True;
$csc=If[$OperatingSystem==="Windows","csc.exe","mcs"]
$tempDirectory=FileNameJoin[{$UserBaseDirectory,"Temp","dotNET"}];


(* ::Input::Initialization:: *)
errId[compiler_String]:=If[compiler==="csc.exe",2,3]


(* ::Input::Initialization:: *)
getLanguage[compiler_String]:=
Switch[compiler
,"csc.exe"|"mcs.bat"|"mcs"|"dmcs.bat","C#"
,"fsc","F#"
,_,Message[dotNETLoad::comperr,compiler];Throw[$Failed]
]


(* ::Input::Initialization:: *)
getNamespace[code_String]:=With[{ns=StringCases[code,"namespace"~~Whitespace~~name:(WordCharacter..):>name]},First@ns/;ns=!={}]


(* ::Input::Initialization:: *)
getType[classCode_String]:=With[{cl=StringCases[classCode,("public"|"")~~""|(Whitespace~~"static"~~Whitespace)~~"class"|"struct"|"module"~~Whitespace~~name:(WordCharacter..):>name]},First@cl/;cl=!={}]


(* ::Input::Initialization:: *)
getType[__]:=Throw[$Failed,error[getType]];


(* ::Input::Initialization:: *)
With[{t=$tempDirectory},
If[!FileExistsQ[t]&&CreateDirectory[t]===$Failed,Message[dotNETLoad::dirmakeerr,t]; $stateValidQ=False]
]


(* ::Input::Initialization:: *)
getSource[class_String,lang_String]:=Which[lang==="C#",FileNameJoin[{$tempDirectory,class<>".cs"}]
,lang==="F#",FileNameJoin[{$tempDirectory,class<>".fs"}]
,True,Message[dotNETLoad::langerr,lang];Throw[$Failed]
]


(* ::Input::Initialization:: *)
runScript[lang_String,compiler_String,source__String,className_String,dir_String,commands___String]:=Which[lang==="C#",
RunProcess[{compiler,"-target:library",commands,"-optimize+","-out:"<>className,source},ProcessDirectory->dir],
lang==="F#",
RunProcess[{compiler,"--target:library","--standalone",commands,"--optimize+","--out:"<>className,source},ProcessDirectory->dir],
True,Message[dotNETLoad::langerr,lang];Throw[$Failed]
]


(* ::Input::Initialization:: *)
dotNETLoad[code_String,compiler_String:$csc,commands___String,opts:OptionsPattern[]]/;$stateValidQ:=
Catch@Module[{sourcePath,run
,lang=getLanguage[compiler]
,namespace=getNamespace[code]
,typeName=getType[code]
,err=errId[compiler]}
,sourcePath=getSource[typeName,lang]
;Export[sourcePath,code,"String"]
;run=runScript[lang,compiler,sourcePath,typeName<>".dll",$tempDirectory,commands]
;If[run[[1]]=!=0
   ,Message[dotNETLoad::cmperr,Style[run[[err]],Red]];$Failed
   ,ReinstallNET[]
   ;LoadNETAssembly@FileNameJoin[{$tempDirectory,typeName<>".dll"}]
   ;If[Head@namespace=!=getNamespace
      ,LoadNETType[namespace<>"."<>typeName,opts,StaticsVisible->True]
      ,LoadNETType[typeName,opts,StaticsVisible->False]]
]
]


(* ::Input::Initialization:: *)
dotNETLoad[code:{__String},compiler_String:$csc,opts:OptionsPattern[dotNETLoad]]/;$stateValidQ:=
Module[{sourcePath,classfiles,nameDir,dll,run
,lang=getLanguage[compiler]
,namespace=Map[getNamespace,code]
,typeName=getType/@code
,err=errId[compiler]}
,If[!SameQ@@namespace
   , Message[dotNETLoad::nameerr];Return[$Failed]
   ,namespace=namespace[[1]]]
;dll=namespace<>".dll"
;classfiles=StringJoin[#,".cs"]&/@typeName
;nameDir=FileNameJoin[{$tempDirectory,namespace}]
;If[!FileExistsQ[nameDir],CreateDirectory[nameDir]]
;sourcePath=FileNameJoin[{nameDir,#}]&/@classfiles
;Do[Export[sourcePath[[i]],code[[i]],"String"],{i,Length@code}]
;run=runScript[lang,compiler,Sequence@@classfiles,dll,nameDir]
;If[run[[1]]=!=0
   ,Message[dotNETLoad::cmperr,Style[run[[err]],Red]];$Failed
   ,ReinstallNET[]
	;LoadNETAssembly@FileNameJoin[{nameDir,dll}]
	;LoadNETType[namespace<>"."<>#,opts,StaticsVisible->True]&/@typeName
]
]


(* ::Input::Initialization:: *)
dotNETLoad[_String]:=CompoundExpression[Message[dotNETLoad::invst],$Failed];


(* ::Input::Initialization:: *)
End[]


(* ::Input::Initialization:: *)
SetAttributes[dotNETLoad,{Locked,Protected,ReadProtected}]


(* ::Input::Initialization:: *)
EndPackage[]
